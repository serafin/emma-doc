Repozytoria i entity
=====================

Wstep
-----

> Domain-Driven Design (skrót DDD) jest to podejście do tworzenia oprogramowania kładące nacisk na takie definiowanie obiektów i komponentów
> systemu oraz ich zachowań, aby wiernie odzwierciedlały rzeczywistość.
> Dopiero po utworzeniu takiego modelu należy rozważyć zagadnienia związane z techniczną realizacją.
http://pl.wikipedia.org/wiki/Domain-Driven_Design


`Entity` - obiekt, ktory ma wyrazną tozsamosc. Np. entity konto bankowe posiada swoja tozsamosc z identyfikatorem.

`Repozytorium` - sluzy do zapisu i odczytu entities. Np. repozytorium kont bankowych, ktore umozliwia odczyt i zapis 

`Serwis` - narzedzie do operacji na entities. Np. serwis przelew, ktory umozliwia przelew srodkow z jednego konta na drugie.


DDD w emma dotycza contentu. Artykul, event, img jest contentem.
Kazdy taki kontent ma wspolna tabele `content`.

```
content_id | content_type | ...
-----------|--------------|----         
         1 | article      | ...
         2 | event        | ...

         
article_id | article_title | ...
-----------|---------------|----         
         1 | Afera zbozowa | ...

         
event_id | event_title  | ...
---------|--------------|----         
       2 | Ubuntu 13.10 | ...
```

Obiekty entity powstaja przez odpowiednie polaczenie.

Jedna z funkcji ddd w emma to wydzielenie wlasciwosci, funkcji dla obiektow. 
Tzn. raz piszemy wlasciwosc lokalizacja, ktora mozemy dowolnie podpinac pod dany content;
raz piszemy obsluge relacji contentow, itd.

DDD to kolejna wartwa danych. DDD jest nad modelem.
Dla utrzymania porzadku w kodzie, praca z modelami f_m ktore dotycza DDD, moze sie odbywac tylko w repozytoriach lub serwisach.
Tzn. mam tabele article, ktora jest wykorzystywana w DDD, wiec nie mozna gdzies w kontrolerze wywoalc m_article::_()->update(); 


Entity
------

Entity to tablica asocjacyjna. 
Np. `article`. 
Struktura tablicy jest zdefiniowana w app/module/article/entity.php

```php
<?php

return 
    require 'module/content/entity/content.php' +
    require 'module/content/entity/contentTree.php' +
    require 'module/content/entity/img.php' +
    require 'module/content/entity/location.php' +
    require 'module/content/entity/tag.php' +
    array(
        'article_id'        => '',  
        'article_title'     => '',  
        'article_author'    => '',  
        'article_teaser'    => '',  
        'article_body'      => '',  
    );

?>
```

Odczyt i zapis entity
---------------------

### Dodawanie entity

```php
<?

$id = $this->module->article->repository->save(array(
    'article_title' => 'Tytul artykulu',
    'article_body'  => 'Tresc artykulu',
    'tag'           => 'Tag, Tag2',
));

f_debug::dump($id, 'ID dodanego artykulu');

?>
```

### Odczyt

Do odczytu sluza metody: 
- `fetch` - pobranie jednego pelnego entity
- `fetchAll` - pobranie wiele entity, nie wszystkie pola/wlasciwosci entity beda uzuplelnione (wzgledy optymalizacji)

Parametry w tych metodach sa takie jak dla modelu i zalezne od danego repozytorium. 
`fetchAll` dodatkowo przyjmuje parametr `paging`. 

```php
<?

$entity = $this->module->article->repository->fetch(array(
    'content_id' => $id,
));

$entities = $this->module->article->repository->fetch(array(
    'content_public' => 'yes',
    'order'          => 'article_title ASC',
    'paging'         => new f_paging(array('limit' => 10)),
));


?>
```

### Aktualizacja entity

```php
<?

$this->module->article->repository->save(array(
    'content_id'    => $id,
    'article_title' => 'Tytul artykulu',
));

?>
```

Metoda `save` zwraca zawsze id, pole `content_id`, dodanego/zaktualizowanego entity.
Id jest liczba naturalna.
Aktualizowne sa tylko te pola, ktore sa przekazywane do metody save. 


### Usuwanie entity

```php
<?

$this->module->article->repository->remove(array(
    'content_id' => $id
));

?>
```

Takie rzeczy jak: generowanie lat/lng wedlug adresu, generowanie uriinner nie moze sie odbywac w srodku repozytorium. 
Musi sie odbyc gdzies wyzej. Repozytirum tylko odczytuje i zapisuje dane.

W importach przed zapisem danych, panelu administracyjnym przed zapisem i po pobraniu danych, 
entity zostanie odpowiednio przekazane do glownego serwisu danego repozytorium do odpowiedniej metody:
- `$this->module->{$module}->serivce->beforeSave(array &$entity)` 
- `$this->module->{$module}->serivce->afterFetch(array &$entity)` 
Tam nalezy trzymac tego typu logike. 
 
 
`content_origin`
----------------

W entity mozna wprowadzic 'klucz obcy' przez pole content_origin. 

```php
<?

// dodanie
$this->module->article->repository->save(array(
    'content_origin' => 'com.blogspot.jakisblog/1234',
    'article_title'  => 'Tytul wpisu na blogu',
));

// aktualizacja
$this->module->article->repository->save(array(
    'content_origin' => 'com.blogspot.jakisblog/1234',
    'article_body'   => 'Tytul wpisu na blogu',
));


// usuniecie
$this->module->article->repository->remove(array(
    'content_origin' => 'com.blogspot.jakisblog/1234',
));


?>
```

Repozytorium w pierwszej kolejnosci patrzy na pole content_id, potem na content_origin.

Wszystkie importy musza pracowac na `content_origin`. 
`content_origin` musi byc stringiem i nie moze byc liczba.
`content_origin` najlepiej definiowac wedlug notacji reverse domain.
Gdzie domena to orginalne zrodlo, pochodzenie tresci. 
Po slashu podac id tresci.
Jezeli z jednej domeny mamy kilka typow danych, kazdy o wlasnej numeracji id to:
`com.blogspot.jakisblog.post/1234`, `com.blogspot.jakisblog.page/8`.



Relacje pomiedzy entities
-------------------------



Relacje pomiedzy entity sa jedno stronne tzn. maja kierunek. 
Entity master posiada powiazane entity slave.
Entity posiada pole `contentRel`, w ktorym sa zapisane relacje do entity slave, kiedy on sam jest w tym polaczeniu masterem.
Wlascicielem relacji jest master.

### Odczyt

Przyklad: artykul 1234 posiada obrazek 2345
```php
<?

$entity = $this->module->article->repository->fetch(array(
    'content_id' => '1234',
));

print_r($entity);

array(
    'content_id' => 1234,
    
    /* ... */
    'contentRel' => array (
        'img' => array(2345),
    ),
    
)
?>
```

`img` jest typem powiazania. 
Nie jest to technicznie typ slavea. 
Narazie bedziemy sie trzymac tego zeby typ polaczenia byl rowny typowi slave'a. 

Technicznie taka relacja odbywa sie przez model

```php
<?php 

class m_contentRel extends f_m
{

    public $contentRel_id_content_master;
    public $contentRel_id_content_slave;
    public $contentRel_type;
    public $contentRel_order;
    public $contentRel_data;

}

?>
```

### Zapis


Pole `contentRel` mozemy dowolnie modyfikowac. 
Tylko podane klucze `contentRel` sa brane pod uwage przy zapisie. Np.

```php
<?php 

// mamy w repozytorium entity:
array(
    'content_id' => 1234,
    /* ... */
    'contentRel' => array (
        'img' => array(11, 12, 13),
    ),
    
);
        
// definiujemy powiazania 1234 z galeriami 21 i 22
$this->module->article->repository->save(array(
    'content_id' => '1234',
    'contentRel'        => array(
        'gallery' => array(21, 22),
    ),
));
        
// po aktualizacji
array(
    'content_id' => 1234,
    /* ... */
    'contentRel' => array (
        'img'     => array(11, 12, 13),
        'gallery' => array(21, 22),
    ),
    
);

?>
```

Przy definiowaniu relacji mozna podac slave'a przez content_origin. 

```php
<?php 

$this->module->article->repository->save(array(
    'content_id' => '1234',
    'contentRel' => array(
        'gallery' => array('com.blogspot.jakisblogasek.gallery/1', 'com.blogspot.jakisblogasek.gallery/2'),
    ),
));

?>
```

Przy zapisie content_origin zostanie zamieniony na content_id i relacja zostanie zapisana. 


### Pobieranie

Pobieranie odbywa sie przez metody fetch i fetchAll z wykorzystaniem parametrow 
`contentRel_id_content_master`, `contentRel_id_content_slave` i `contentRel_type`.
Trzeba tylko wiedziec co jest z czym powiazane i w ktora strone.

Np. Chcemy pobrac wszystkie galerie artykuly 1234 czyli master to 1234 i typ relacji to typ slave'ow

```php
<?php 

$entities = $this->module->gallery->repository->fetchAll(array(
    'contentRel_id_content_master' => '1234',
    'contentRel_type'              => 'gallery',
    'order'                        => 'contentRel_order',
));

?>
```

`tree` tez jest content. 
W wiazaniu `tree` z innym contentem nie tree, tree jest slavem. Tzn tak jak sie przyczepia obrazki do artykulu tak samo sie przyczepia wezly drzewa do artykulu.

Np. pobieranie artykulow powiazanych z `tree` o id `31`:

```php
<?php 

$entities = $this->module->article->repository->fetchAll(array(
    'contentRel_id_content_slave' => '31',
    'content_type'                => 'article',
    'order'                       => 'content_order',
    'limit'                       => 10,
));

?>
```

### Dodatkowe dane powiazania

W relacji mozna przekazac dodatkowe dane np. obraz moze miec swoj opis i przy relacji z artykulem inny opis.
Pojedynczym powiadaniem moze byc 
- liczba naturalna, czyli `content_id`,
- string, czyli `content_origin`
- tablica asocjacyjna z kluczem `content_id` (lub `content_origin`) i kluczem `data`

```php
<?php

$this->module->article->repository->save(array(
    'content_id' => '1234',
    'contentRel' => array(
        'gallery' => array(
            array('content_id' => 61, 'data' => array('img_desc' => 'Inny opis obrazka')),
            array('content_origin' => 'com.blogspot.jakisblogasek.img/3', 'data' => array('img_desc' => 'Jeszcze inny opis obrazka'))
            
        ),
    ),
));

?>
```

Mozna tez uzyc pola `content_origin` przy zapisie. Przy pobieraniu zawsze bedzie pole `content_id`


Tworzenie repozytorium
----------------------

/** @todo */


Tworzenie zaawansowanego repozytorium
-------------------------------------

/** @todo */


Tworzenie subcontentu
---------------------

/** @todo */

